# Meta History

Records of tournament outcomes and review insights once a pull request wraps. Each entry captures the winning variant, the key rationale, notable imports, and review feedback so we can reuse what worked (and avoid what didn’t) on future waves.

## C7 — Meta Prompt Pack++
- **Winner**: `var4` (branch `var4-base`, commit `d06a547d95f0f1bce33158ccacecc0bbb095ba0b`)
- **Why it won**:
  - Enforced port-level dependency checks in the greedy solver, matching the updated prompt expectations.
  - Added explicit confidence, residual risk, and rejection tracking across the rubric, schema, and templates.
  - Preserved coverage/examples so meta reviewers can run `node tm.mjs meta --respect-requires` without manual edits.
- **Imports pulled in**:
  - From `var1`: richer scorecard fields (facet rationales, default `rejected_alternatives` entries).
  - From `var2`: dependency bundling logic to auto-include required providers.
  - From `var3`: deduplication guard to avoid emitting the same module ID twice.
- **Why other variants fell short**:
  - `var1` matched `requires[]` against module IDs instead of ports, so dependencies never resolved.
  - `var2` abandoned candidates when multiple providers existed; it also relied on module-name resolution, so port requirements still failed.
  - `var3` normalized dependency checks to base module names, leading to false negatives and schema mismatches (`follow_ups` typo).
- **Review feedback addressed**:
  - *Codex*: Updated `spec/report.schema.json` so `rejected_alternatives` accepts `{variant, reason, confidence}` objects.
  - *Gemini*: Adjusted solver to choose the best provider (risk/evidence heuristic) instead of failing on ambiguity, and added duplicate-provider penalties during gain calculation.
- **Tradeoffs**: Skipping modules until dependencies are satisfied may leave certain goals uncovered without additional providers, but keeps plans dependency-safe.
- **Open questions**: Should the planner automatically discover manifests when coverage omits provides_ports metadata?
- **Residual risks**: Coverage producers that omit provides_ports/requires will see their modules dropped under --respect-requires.
- **Follow-ups / TODOs**: Consider adding manifest discovery so the meta solver can infer dependencies when annotations are missing.

## C8–C10 — Lessons Miner · SafetyPort Pack · Winner Pack Smoke
- **Winner**: `var1` (branch `var1-base`, commit `c2e593c38202cc4072f4a79a352a25d3a99f49a2`)
- **Why it won**:
  - Shipped the new `tm lessons mine` CLI plus docs/fixtures so follow-ups and residual risks collapse into a deterministic JSON feed.
  - Hardened the SafetyPort example for Windows (normalisation + reserved-device guards) and added the platform-specific harness that exercises real cases on Windows but skips cleanly elsewhere.
  - Added optional `--npm-pack` smoke in shipping gates and taught the TypeScript composer to emit winner/package.json, keeping packaging checks fast and cleanup automatic.
- **Imports pulled in**:
  - From `var2`: richer npm-pack telemetry (NPM_PACK_* events, summary wiring, tarball cleanup) and the improved Windows harness that locates the module via `__dirname`.
- **Why other variants fell short**:
  - `var2` mixed in a second lessons implementation that depended on the `glob` package and left dead CLI helpers behind.
  - `var3` only normalised Windows paths; its `isSafe` logic still allowed UNC/relative inputs, so Windows tests never caught unsafe cases.
  - `var4` skipped the SafetyPort changes entirely, so the Windows fixtures wouldn’t validate anything.
- **Review feedback addressed**:
  - Removed the duplicate lessons-helper block and the unused `npmPackSmoke` stub (Gemini caught both) and dropped the `glob` dependency.
  - Outstanding: tighten `globHasWildcards` to match the supported syntax and trim the unreachable check in the SafetyPort path logic (tracked for the next patch).
- **Tradeoffs**: Custom glob expansion avoids new dependencies, but only supports `*`/`?`; more complex patterns still require manual curation.
- **Open questions**: Confirm npm-pack smoke and the Windows harness on a native Windows runner, and decide if lessons should attribute follow-ups to source reports.
- **Residual risks**: npm-pack smoke skips when npm is absent, so packaging gaps can hide on stripped environments.
- **Follow-ups / TODOs**:
  - Exercise the Windows SafetyPort pack in CI (docs/report.json).
  - Extend the lessons miner with source attribution for follow-ups/residual risks.
  - Align the glob helper and SafetyPort guard per outstanding review notes.

## C11–C12 — Compose Overrides · CI Polish
- **Winner**: `codex/add-override-file-support-for-composed-plans` (commit `15479f3116585ceb08476fdd8e65e3d3ec007455`)
- **Why it won**:
  - Added `--overrides` support end-to-end (`tm compose` + `tm gates`), including module/wiring removal, deterministic ordering, winner `compose.merged.json`, and `COMPOSE_OVERRIDES_APPLIED` telemetry that stays on stderr when events stream.
  - Documented override semantics, shipped the `examples/compose.overrides/` fixture, and ensured winner reports mirror the merged plan.
  - Split CI into `schemas`, `composer_gates`, and `rust_check` jobs with dependency-aware caching for Node (`~/.npm`, `node_modules`) and Cargo (`~/.cargo`, `target`).
  - Restored the duplicate-provider failure/resolution checks and TypeScript composer scaffold inside CI, while validating override/gates NDJSON streams and exporting a parsed override summary artifact.
- **Imports pulled in**: N/A (feature work on mainline scaffolds).
- **Why other variants fell short**: N/A (single-track delivery).
- **Review feedback addressed**:
  - Routed override summaries through the event emitter’s `info` channel so NDJSON output stays clean under `--emit-events`.
  - Added artifact capture for override details and regrouped CI logging for easier audit review.
- **Tradeoffs**: Override removals still use ad-hoc markers (`"-module"` strings, `{remove:true}` wiring flags); a future schema might expose first-class delete semantics.
- **Open questions**: Should overrides eventually cover glue/run metadata, and do we surface override diffs directly in winner artifacts beyond the CI summary?
- **Residual risks**: Cached `node_modules`/Cargo targets can drift if lockfiles change without cache busting; ensure keys stay aligned.
- **Follow-ups / TODOs**:
  - Monitor override usage patterns to decide whether CLI should emit a structured diff artifact (beyond CI) or accept layered override files.

## C13–C14 — MCP Façade · Contributor Playbook (Follow-up)
- **Winner**: `codex/implement-mcp-facade-documentation-and-tools` (commit `9e5f75dac4f1646c543caf8e6316a51c35234315`)
- **Why it won**:
  - Extended `mcp/server.mjs` with optional `respectRequires`, overrides, and `strictEvents`, aligning agent workflows with CLI behavior.
  - Hardened error handling so responses always include CLI context, structured error codes, and gate events—even when commands fail.
  - Published detailed façade docs (`docs/mcp.md`) and a four-phase contributor playbook so humans and agents share the same validation loop.
- **Imports pulled in**: N/A (iteration on the Wave 6 façade).
- **Why other variants fell short**:
  - `var2` required the MCP SDK during offline `npm ci`, breaking sandbox installs.
  - `var3` returned bare compose JSON from `tm.meta`, violating the documented `{ compose: … }` envelope.
  - `var4` reimplemented MCP framing manually, diverging from the official SDK’s transport and schema validation.
- **Review feedback addressed**:
  - Clarified docs/tests that strict events are opt-in and tightened messaging about the SDK fallback.
  - Updated the stub server to store tool definitions so schema issues surface during offline testing.
- **Tradeoffs**: Exposing CLI args/stdout/stderr in MCP errors accelerates debugging but can leak absolute paths in agent logs.
- **Open questions**: Should we add automated MCP integration tests once the SDK is vendored, and do we want to emit override diff artifacts outside CI summaries?
- **Residual risks**: Agents still need to install the real SDK when network access returns; stub mode can mask transport mismatches until then.
- **Follow-ups / TODOs**:
  - Land a lightweight MCP smoke test (docs or CI) to keep `respectRequires`/`overrides`/`strictEvents` exercised.
  - Evaluate vendoring or pinning the MCP SDK to avoid future install drift.

## E1–E3 — Meta Scorer v1 · Events Validate/Replay
- **Winner**: `codex/implement-deterministic-meta-scorer` (commit `600fce7f8dbf6b6f0cf83f98a4eb2ed1f3fd5d6e`)
- **Why it won**:
  - Refactored `tm meta` into a feasible-greedy scorer with profile-driven weights, deterministic tie breakers, and `META_PICK` telemetry that captures gain drivers.
  - Added `tm events validate`/`tm events replay` commands plus CI checks that diff consecutive runs and publish meta/gate timelines for auditability.
  - Expanded documentation (`docs/meta-scorer.md`, `docs/events.md`) and sample NDJSON so operators and agents can consume the new workflows.
- **Imports pulled in**: Built on the Wave 7 v1 design; no external imports.
- **Why other variants fell short**:
  - `var2` skipped archiving replay output and left documentation light.
  - `var3` lacked the replay helper and didn’t integrate validation with the sample NDJSON.
  - `var4` reverted to manual checks without the new commands or deterministic profiles.
- **Review feedback addressed**: Made the meta `run_id` deterministic so CI diffs pass, per Gemini/Codex review and failing CI logs.
- **Tradeoffs**: Running meta twice adds minor CI time but guarantees deterministic output; verbose errors surface absolute paths in logs.
- **Open questions**: Should we add broader coverage fixtures for determinism tests and retain diffs when failures occur?
- **Residual risks**: The example coverage set may not cover every edge case; future changes must regenerate baselines when behaviour shifts.
- **Follow-ups / TODOs**:
  - Capture additional coverage fixtures for determinism validation.
  - Consider archiving meta diff outputs to ease debugging when CI fails.

## E2 — Headless Codex Cloud Kit
- **Winner**: `codex/implement-headless-bo4-execution-pipeline` (commit `bc2eb7810533c0e596d9bb21bbb9bad03b1e4ec0`)
- **Why it won**:
  - Delivered the full watcher → harvest → meta → compose → gates loop as standalone scripts (`codex-watch.mjs`, `bo4-harvest.mjs`, `bo4-meta-run.mjs`, `bo4-compose.mjs`, `bo4-apply.sh`) with a shared `run.json` manifest and hardened module validation (`E_VARIANT_NO_MODULES` exits).
  - Added an orchestrator (`bo4-loop.mjs`) plus CI coverage (`headless_cloud` job) that runs against a stubbed Codex Cloud (`CODEX_BIN=node scripts/tests/codex-cloud-stub.mjs`) and validates event telemetry.
  - Documented the workflow (`docs/headless-cloud.md`) and clarified that exported variants live under `.codex-cloud/variants/<task_id>/varN/` to keep the repo clean while maintaining durable artifacts.
  - Shored up the CLI after review: removed `shell: true` spawns, introduced `resolveCommand` so multi-word `CODEX_BIN` values work safely, and extracted a reusable manifest helper for the apply script.
- **Imports pulled in**: Borrowed the recursive True Module checks and winner selection rationale from the stronger Wave 8 submissions while retaining var2’s manifest structure and CI job skeleton.
- **Why other variants fell short**:
  - `var1` required a caller-supplied modules path and `rsync`’d the winner into the repo root, making it unsafe for automation.
  - `var3` overwrote watcher telemetry during gates and never recorded `compose_sha256` at the manifest root.
  - `var4` left modules outside the manifest, demanded manual `--modules-root`, and didn’t integrate the headless loop into CI.
- **Review feedback addressed**:
  - Resolved security concerns by eliminating shell-based spawns and adding the new command resolver.
  - Seeded deterministic fixtures under `examples/cloud-stub/variants/var0/` with matching coverage (`examples/coverage.json`) so the CI job stops looping.
  - Updated `.gitignore` and docs to account for the out-of-repo variant archive while still tracking the stub fixtures needed for tests.
- **Tradeoffs**:
  - The command splitter is intentionally simple; complex quoting (nested quotes, environment substitutions) will need future hardening.
  - The stub variant reuses production module sources, increasing fixture surface area but allowing end-to-end smoke tests without Codex Cloud access.
  - Storing artifacts under `.codex-cloud` avoids repo churn at the cost of extra coordination when other tools expect in-repo diffs.
- **Open questions**:
  - Should we add automated cleanup or rotation for `.codex-cloud/variants` to avoid stale artifacts?
  - Do we want richer stub tasks (multiple variants, failure cases) to exercise branching paths in CI?
- **Residual risks**:
  - Changes to module IDs or coverage goals require manual fixture regeneration; CI will fail noisily if the stub drifts.
  - `resolveCommand` currently handles only basic whitespace/quote patterns; unusual shells or Windows paths may still break.
- **Follow-ups / TODOs**:
  - Capture at least one failing/headless gate scenario in fixtures to keep the error-path logic tested.
  - Explore packaging a helper that syncs `.codex-cloud` artifacts to cloud storage for longer-term retention.
  - Consider wiring a smoke test that runs `bo4-apply.sh` in mock mode to verify manifest parsing and branch creation do not regress.

## E4–E5 — Oracles + Side-Effects Enforcement
- **Winner**: `task_e_68ed97f4a89c8320b26b3c08b8163c09` · var4 (pending merge)
- **Why it won**:
  - Introduced a full oracle toolchain: Ajv-backed spec validation (`spec/oracle.schema.json`), a default `tm oracles run` workflow that auto-discovers specs, and reusable helpers for executing cases under guard instrumentation.
  - Wired the shipping gates `--with-oracles` flag so oracle cases publish `ORACLE_*` events, feed per-module side-effect telemetry, and enrich the gate summary with observed vs declared operations plus outside-root write detection.
  - Added a Node-based guard (`scripts/side-effects-guard.mjs`) and library helpers to capture filesystem writes and process launches, producing actionable `E_SIDEEFFECTS_DECLARATION` / `E_SIDEEFFECTS_FORBIDDEN` errors with sample paths/commands.
  - Documented the end-to-end flow in `docs/oracles.md`, covering schema expectations, CLI defaults, and the new telemetry.
- **Imports pulled in**:
  - Borrowed var2’s JSON-schema approach (now codified as `spec/oracle.schema.json`) to catch malformed specs before execution.
  - Adopted var3’s focus on summarising side effects per module, extending it with richer sampling and event emission.
- **Why other variants fell short**:
  - `var1` lacked schema validation and only captured stdout/stderr, making file-based determinism checks impossible.
  - `var2` didn’t verify writes stayed within module roots and failed to observe child processes spawned inside module scripts.
  - `var3` required callers to pass `--spec` manually and still allowed external writes to pass so long as `FS:write` was declared.
- **Review feedback addressed**:
  - Hardened the run commands to allow multi-token `CODEX_BIN` without reintroducing command-injection risks.
  - Exposed richer gate telemetry (`summary.side_effects`, `SIDEEFFECTS_SUMMARY`) and ensured oracle specs can be skipped gracefully when no files match.
- **Tradeoffs**:
  - The guard only instruments Node APIs; native helpers or other runtimes still need bespoke hooks.
  - Sampled telemetry intentionally caps the number of paths/commands to keep summaries digestible, potentially hiding long-tail operations.
- **Open questions**:
  - Should we extend the guard to flag read-only access patterns (e.g., unexpected `FS:read` outside module roots)?
  - Do we want oracle-specific summaries similar to the shipping-gate aggregate, especially when running the CLI standalone?
- **Residual risks**:
  - Teams must still update module manifests manually; missing declarations are only caught once tests run under guard.
  - Complex specs that depend on non-Node tooling may evade detection until additional instrumentation is added.
- **Follow-ups / TODOs**:
  - Add negative fixtures exercising `E_ORACLE_NONDETERMINISM`/`E_SIDEEFFECTS_FORBIDDEN` in CI to keep coverage strong.
  - Explore extending the guard to observe non-Node subprocesses (e.g., Git hooks invoking shell scripts).
  - Consider caching validated oracle specs to avoid repeatedly compiling large Ajv schemas in long-running sessions.

## E6–E7–E8 — Port Version Negotiation · SafetyPort Deep Suite · Performance & Caching
- **Winner**: `task_e_68edadaef2ec8320ba60f77e1c726ae4` · var2
- **Why it won**:
  - Hardened provider analysis so mixed majors now raise `E_PORT_VERSION_AMBIG` unless wiring or `preferred_providers` selects a single major, and surfaced inactive majors in `tm compose --explain`.
  - Made the TypeScript composer hash module/glue trees before copying and stash digests under `winner/.tm/copy-hashes.json`, avoiding redundant syncs on warm runs.
  - Instrumented shipping gates with phase timing (`GATES_SUMMARY`), cached ESLint/tsc work in `.tm/`, and accepted explicit `TEST_SKIPPED` directives so platform-specific runners contribute telemetry without failing Linux/mac builds.
  - Expanded the SafetyPort fixtures with TypeScript-powered runners that assert normalization/guard behaviour on both POSIX and Windows paths.
- **Imports pulled in**:
  - Reused the `.tm` cache pattern from earlier headless tooling work to persist ESLint/tsc artefacts between runs.
- **Why other variants fell short**:
  - `var1` mis-flagged negotiated majors and failed the warm-run tests once constraints were present.
  - `var3` did not clear inactive providers, so `--explain` still reported conflicting majors and lint timing never landed in phase telemetry.
  - `var4` relied on heuristic skip detection and left major negotiation in a half-active state, risking false positives in event consumers.
- **Review feedback addressed**:
  - Tightened skip handling so exit code `64` only counts when the runner emits a `TEST_SKIPPED` directive, preventing accidental passes on other failures.
  - Simplified symlink detection in the composer hash walker and surfaced non-`ENOENT` readlink errors per Gemini feedback.
- **Tradeoffs**:
  - Hashing entire module trees adds CPU to the cold path; extremely large winners might still need a more incremental strategy.
  - Cached lint/tsc artefacts live under `.tm/`; callers must remember to purge it when dependency graphs change.
- **Open questions**:
  - Should we surface port-major negotiation results in winner metadata for downstream auditing?
  - Do we want CI to assert cached TypeScript phases beyond the current examples?
- **Residual risks**:
  - Hash-based copy detection assumes stable file content; generated artefacts with nondeterministic timestamps will still thrash the cache.
  - Platform skip directives rely on runner discipline—missing JSON markers now fail the gate, but richer diagnostics may help authors debug quickly.

## F1–F2 — MCP Integration Tests · Python Shim
- **Winner**: `task_e_68edca68ef4c83209992ed0dc004f30d` · var2
- **Why it won**:
  - Added `mcp/tests/smoke.mjs`, which boots the façade, exercises `tm.meta`, `tm.compose`, and `tm.gates`, captures events, and leaves deterministic JSON fixtures under `artifacts/mcp/`.
  - Introduced a `mcp-smoke` GitHub Action that caches dependencies, runs the smoke script, and uploads the captured responses for reviewers.
  - Published `python/tm_cli.py` plus docs so non-Node agents can stream JSON requests to `tm.mjs` and receive structured responses with preserved error codes and gate events.
- **Imports pulled in**:
  - Reused the `.tm` artifact structure to keep smoke outputs consistent (e.g., `artifacts/mcp/meta.json`, `compose.json`, `gates.json`).
- **Why other variants fell short**:
  - `var1` required callers to manage temp files manually and lacked stdin-driven JSON, breaking the acceptance criteria for the Python shim.
  - `var3` dropped tm exit metadata when both gates and event parsing failed, hiding the original CLI error.
  - `var4` suppressed tm stdout/stderr entirely, making debugging harder and forcing clients to rely on silent failures.
- **Review feedback addressed**:
  - Updated the smoke test to use `os.tmpdir()` and wait for façade output instead of a fixed delay, preventing leaks and race conditions.
  - Tightened the shim so intermediate files are compact JSON while the `--pretty` flag only affects final output.
- **Tradeoffs**:
  - Running shipping gates as part of the smoke adds a few seconds to CI latency.
  - The shim still shells out to Node; environments without `node` must configure `TM_NODE_BIN` explicitly.
- **Open questions**:
  - Should we add JSON-RPC transport coverage once the official MCP SDK is bundled?
  - Do we want to expose a “debug” toggle so the stub can emit verbose logs when needed?
- **Residual risks**:
  - MCP smoke relies on stdout/stderr heuristics; façade changes that alter startup logging could require test tweaks.
  - Python wrapper error envelopes now mirror tm codes, but downstream tooling must still handle non-zero exit statuses correctly.

## F3–F4 — `tm doctor` · `tm init` · Winner Publish (npm-pack)
- **Winner**: `var1`
- **Why it won**:
  - Extended `tm doctor` with `--artifacts`, persisted `doctor.json`, and downgraded `doctor_artifact` to warnings when writes fail so diagnostics survive read-only hosts.【../.codex-cloud/variants/task_e_68ede47fd8b08320870000d6d9e96fd7/var1/var1/patch.diff:1444-1620】
  - Introduced `tm init` with base/TypeScript/MCP template layers that scaffold modules, docs, CI, and README guidance from a single command.【../.codex-cloud/variants/task_e_68ede47fd8b08320870000d6d9e96fd7/var1/var1/patch.diff:600-714】【../.codex-cloud/variants/task_e_68ede47fd8b08320870000d6d9e96fd7/var1/var1/patch.diff:1710-1754】
  - Wired `--npm-pack` into shipping gates, copying tarballs/logs into `artifacts/` and surfacing failures as `E_NPM_PACK` with actionable diagnostics.【../.codex-cloud/variants/task_e_68ede47fd8b08320870000d6d9e96fd7/var1/var1/patch.diff:1783-1844】
  - Refreshed contributor/composer docs so operators run `tm doctor --artifacts …` and review packaging smoke outputs by default.【../.codex-cloud/variants/task_e_68ede47fd8b08320870000d6d9e96fd7/var1/var1/patch.diff:33-197】
- **Imports pulled in**:
  - None.
- **Why other variants fell short**:
  - No alternate variants completed the brief for this task cycle, so there were no additional changes to import.
- **Review feedback addressed**:
  - Hardened lessons mining/doctor writes with structured error codes and captured the implementation snapshot in `docs/report.json` for posterity.【../.codex-cloud/variants/task_e_68ede47fd8b08320870000d6d9e96fd7/var1/var1/patch.diff:1432-1440】【../.codex-cloud/variants/task_e_68ede47fd8b08320870000d6d9e96fd7/var1/var1/patch.diff:285-340】
- **Tradeoffs**: Doctor now touches disk on every run; read-only environments emit warnings that developers must review.
- **Residual risks**: CI still treats doctor as non-blocking, so artifact warnings depend on human follow-up.【../.codex-cloud/variants/task_e_68ede47fd8b08320870000d6d9e96fd7/var1/var1/patch.diff:370-399】
- **Follow-ups / TODOs**:
  - Add regression coverage for `doctor_artifact` warnings so future refactors keep the edge case tested.【../.codex-cloud/variants/task_e_68ede47fd8b08320870000d6d9e96fd7/var1/var1/patch.diff:456-463】

## F5–F6 — Events Summary/Viz · Auto Lessons Hook
- **Winner**: `var1`
- **Why it won**:
  - Shipped `scripts/events-summarize.mjs`, which turns gate NDJSON into deterministic JSON/Markdown dashboards and prints a TTY table for quick log review.【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var1/var1/patch.diff:294-412】
  - Added `tm events summary` so both CI and humans can generate the same artifacts with a single flag set.【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var1/var1/patch.diff:814-838】
  - Delivered `scripts/lessons-auto.sh` (with an optional `--commit` path) and a main-branch workflow that reruns shipping gates, creates summaries, mines lessons, and uploads everything in one run.【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var1/var1/patch.diff:6-61】【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var1/var1/patch.diff:653-739】
  - Updated `docs/events.md`, `docs/lessons.md`, and `docs/report.json` to explain how to consume the new artifacts and feed `lessons.json` into future prompts.【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var1/var1/patch.diff:63-152】【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var1/var1/patch.diff:129-193】
- **Imports pulled in**:
  - None.
- **Why other variants fell short**:
  - `var2` and `var3` only supported artifact uploads (no commit mode), and `var3` even ignored `lessons.json` via `.gitignore`, blocking the follow-up prompt seeding workflow.【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var2/var2/patch.diff:767-780】【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var3/var3/patch.diff:122-139】【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var3/var3/patch.diff:728-751】
  - `var4` required a trailing `GATES_SUMMARY` event and aborted otherwise, making the summarizer fragile for partial streams.【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var4/var4/patch.diff:417-434】
- **Review feedback addressed**:
  - Added structured `E_SUMMARY_PARSE` handling and recorded the automation snapshot in reporting docs.【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var1/var1/patch.diff:599-709】【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var1/var1/patch.diff:287-340】
- **Tradeoffs**: The lessons workflow reruns shipping gates on `main`, increasing CI minutes but guaranteeing fresh telemetry.
- **Residual risks**: If gates fail upstream, the workflow skips uploads, so reviewers must still monitor artifacts for completeness.
- **Follow-ups / TODOs**:
  - Enable the commit path once bot credentials exist so mined lessons land automatically when appropriate.【../.codex-cloud/variants/task_e_68ef1460aa0c8320b4b250ab4f51d361/var1/var1/patch.diff:739-740】
