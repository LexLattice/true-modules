#!/usr/bin/env node
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

import { tmError, analyzeProviders } from '../../../scripts/lib/provider-analysis.mjs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const args = new Map(
  process.argv.slice(2).reduce((acc, value, idx, arr) => {
    if (!value.startsWith('--')) return acc;
    return acc.concat([[value.slice(2), arr[idx + 1]]]);
  }, [])
);

const composePath = path.resolve(args.get('compose') || './compose.json');
const modulesRoot = path.resolve(args.get('modules-root') || './modules');
const glueRoot = path.resolve(args.get('glue-root') || './glue-catalog');
const outDir = path.resolve(args.get('out') || './winner');

async function readJSON(p) {
  const txt = await fs.readFile(p, 'utf8');
  return JSON.parse(txt);
}

function manifestPath(root, id) {
  return path.join(root, id, 'module.json');
}

async function copyDir(src, dst) {
  await fs.mkdir(dst, { recursive: true });
  if (fs.cp) {
    await fs.cp(src, dst, { recursive: true });
  } else {
    const { execSync } = await import('child_process');
    execSync(`cp -R "${src}/." "${dst}"`);
  }
}

function normalizePortName(entry) {
  return (entry || '').split('@')[0];
}

(async () => {
  const compose = await readJSON(composePath);
  await fs.mkdir(outDir, { recursive: true });

  // Load manifests
  const manifById = {};
  for (const mod of compose.modules || []) {
    const mp = manifestPath(modulesRoot, mod.id);
    manifById[mod.id] = await readJSON(mp);
  }

  const { warnings } = analyzeProviders(compose, manifById);
  for (const warning of warnings) {
    console.warn(warning);
  }

  const providers = {};
  for (const [id, man] of Object.entries(manifById)) {
    for (const p of (man.provides || [])) {
      const name = normalizePortName(p);
      if (!providers[name]) providers[name] = [];
      providers[name].push(id);
    }
  }

  // Requires check
  const providedPorts = new Set(Object.keys(providers));
  const reqProblems = [];
  for (const [id, man] of Object.entries(manifById)) {
    for (const req of (man.requires || [])) {
      const name = normalizePortName(req);
      if (!providedPorts.has(name)) {
        reqProblems.push(`${id} requires ${req} but no selected module provides ${name}`);
      }
    }
  }
  if (reqProblems.length) {
    throw tmError('E_REQUIRE_UNSAT', 'Port requires unsatisfied:\n' + reqProblems.join('\n'));
  }

  const winnerModulesDir = path.join(outDir, 'modules');
  await fs.mkdir(winnerModulesDir, { recursive: true });
  for (const mod of compose.modules || []) {
    await copyDir(path.join(modulesRoot, mod.id), path.join(winnerModulesDir, mod.id));
  }

  const winnerGlueDir = path.join(outDir, 'glue');
  await fs.mkdir(winnerGlueDir, { recursive: true });
  for (const glue of compose.glue || []) {
    if (!glue || !glue.id) continue;
    await copyDir(path.join(glueRoot, glue.id), path.join(winnerGlueDir, glue.id));
  }

  const portsMap = Object.fromEntries(Object.entries(providers).map(([port, ids]) => [port, ids]));
  await fs.writeFile(path.join(outDir, 'ports.map.json'), JSON.stringify(portsMap, null, 2));

  const report = {
    context: {
      run_id: compose.run_id || new Date().toISOString(),
      composer: 'ts-composer@0.1',
      generated_at: new Date().toISOString()
    },
    bill_of_materials: (compose.modules || []).map(m => ({
      id: m.id,
      version: m.version || '0.0.0'
    })),
    wiring: compose.wiring || [],
    glue: compose.glue || [],
    constraints: compose.constraints || [],
    notes: [
      'MVP composer copied selected modules/glue; link/build remains app responsibility.'
    ]
  };
  await fs.writeFile(path.join(outDir, 'report.json'), JSON.stringify(report, null, 2));
  await fs.writeFile(path.join(outDir, 'README.md'), '# Winner workspace (MVP)\n');

  const pkg = {
    name: 'true-modules-winner',
    private: true,
    version: '0.1.0',
    type: 'module',
    description: 'Materialized workspace generated by True Modules composer (MVP)'
  };
  await fs.writeFile(path.join(outDir, 'package.json'), JSON.stringify(pkg, null, 2));

  const tsconfig = {
    compilerOptions: {
      target: 'ES2020',
      module: 'ES2020',
      moduleResolution: 'node',
      esModuleInterop: true,
      resolveJsonModule: true,
      allowSyntheticDefaultImports: true,
      strict: false
    },
    include: ['modules/**/*', 'glue/**/*']
  };
  await fs.writeFile(path.join(outDir, 'tsconfig.json'), JSON.stringify(tsconfig, null, 2));

  console.log('âœ“ Composer wrote', outDir);
})().catch(err => {
  console.error('composer error:', err.message);
  process.exit(1);
});
